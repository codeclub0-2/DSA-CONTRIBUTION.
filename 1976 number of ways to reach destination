/*
===============================================================================
üöÄ LeetCode 1976 - Number of Ways to Arrive at Destination 
    
üìå Problem Statement:

You are given a weighted, undirected graph with `n` nodes (0 to n-1) 
and a list of edges `roads`. Each edge is represented as:

    roads[i] = {u, v, w}

- u and v are the nodes connected by the edge.
- w is the weight (travel time) of the edge.

Task: Calculate the number of distinct shortest paths from node 0 to node n-1.  
Return the answer modulo 1e9 + 7.

---

üí° Example:

Input:
n = 7
roads = {
  {0,6,7}, {0,1,2}, {1,2,3}, {1,3,3}, {6,3,3},
  {3,5,1}, {6,5,1}, {2,5,1}, {0,4,5}, {4,6,2}
}

Output:
4

Explanation:
The shortest distance from node 0 to node 6 is 7.  
There are 4 different paths that achieve this shortest distance.  

---

‚öôÔ∏è Approach:

We use Dijkstra's algorithm with a modification to count the number of shortest paths:

1. Maintain `dist[i]` = shortest distance from 0 to node i.
2. Maintain `ways[i]` = number of shortest paths from 0 to node i.
3. For each edge relaxation:
   - If a shorter path is found, update distance and set ways[v] = ways[u].
   - If an equal path is found, increment ways[v] += ways[u].
4. Answer = ways[n-1].

Time Complexity: O(E log V)  
Space Complexity: O(V + E)
===============================================================================
*/

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) {
        vector<vector<pair<int,int>>> adj(n);
        for (auto &r : roads) {
            int u = r[0], v = r[1], w = r[2];
            adj[u].push_back({v, w});
            adj[v].push_back({u, w});
        }

        vector<long long> dist(n, LLONG_MAX);
        vector<int> ways(n, 0);
        int MOD = 1e9 + 7;

        priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
        dist[0] = 0;
        ways[0] = 1;
        pq.push({0, 0});

        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();

            if (d > dist[u]) continue;

            for (auto [v, w] : adj[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    ways[v] = ways[u];
                    pq.push({dist[v], v});
                } else if (dist[u] + w == dist[v]) {
                    ways[v] = (ways[v] + ways[u]) % MOD;
                }
            }
        }

        return ways[n-1];
    }
};

